package listen

import (
	"bufio"
	"fmt"
	"io"
	"net"
	"os"
	ftime "public_tool/time"
	"sync"
)

var empty []byte = []byte{}

func ListenServer(IP string) {
	lis, err := net.Listen("tcp", IP)
	if err != nil {
		fmt.Println(ftime.LineTime(), " ", err)
		os.Exit(1)
	}
	for {
		con, err := lis.Accept()
		if err != nil {
			continue
		}
		go HandleMessage(con)
	}
}

func HandleMessage(con net.Conn) {
	buf := getReadPool(con)
	defer func(con net.Conn, b *bufio.Reader) {
		putReadPool(b)
		con.Close()
	}(con, buf)
	for {
		msg, err := ReadMsg(buf)
		if err != nil {
			fmt.Println(err)
			break
		}
		fmt.Println(string(msg))
		io.WriteString(con, "Hello World")
	}
}

var bufRead sync.Pool

func ReadMsg(b *bufio.Reader) ([]byte, error) {
	by, _, err := b.ReadLine()
	if err != nil {
		return empty, err
	}
	return by, nil
}

func getReadPool(r io.Reader) *bufio.Reader {
	if v := bufRead.Get(); v != nil {
		br := v.(*bufio.Reader)
		br.Reset(r)
		return br
	}
	return bufio.NewReader(r)
}

func putReadPool(br *bufio.Reader) {
	br.Reset(nil)
	bufRead.Put(br)
}
