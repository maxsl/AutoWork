package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"net"
	"strings"
	"sync"
	"time"
)

func cmain() {
	lis, err := net.Listen("tcp", "0.0.0.0:1789")
	if err != nil {
		fmt.Println(err)
		return
	}
	defer lis.Close()
	for {
		con, err := lis.Accept()
		if err != nil {
			fmt.Println(err)
			continue
		}
		go Hander(con)
	}
}

func Hander(con net.Conn) {
	defer con.Close()
	ip := strings.Split(con.RemoteAddr().String(), ":")[0]
	defer statusMap.Del(ip)
	if !statusMap.Add(ip) {
		fmt.Fprint(con, "AlreadyExist")
		return
	}
	buf := getrwcPool(con)
	defer putrwcPool(buf)
	line, _, err := buf.ReadLine()
	if err != nil || string(line) != "Auth" {
		return
	}
	for {
		line, _, err = buf.ReadLine()
		if err != nil {
			return
		}
		msg, err := decode(line)
		if err != nil {
			_, err = fmt.Fprint(buf, "UnknowType")
			if err != nil {
				return
			}
			continue
		}
		if b, err := handlerMsg(msg, ip); err != nil {
			fmt.Fprint(buf, "JobExecError")
			putJsonPool(msg)
			continue
		} else {
			buf.Write(b)
		}
		putJsonPool(msg)
	}
}

func handlerMsg(msg *Msg, ip string) ([]byte, error) {
	handmsg(msg, ip)
	b, err := encode(msg)
	if err != nil {
		return empty, err
	}
	return b, nil
}

func handmsg(m *Msg, ip string) {
	switch m.Action {
	case "Test.Ping":
		statusMap[ip] = getNow()
	case "Scripts":
		m.JobID = NewID()
		m.Remark = fmt.Sprintf("%d", getNow())
		fmt.Println("开始执行脚本")
	case "Wget":
		m.JobID = NewID()
		m.Remark = fmt.Sprintf("%d", getNow())
		fmt.Println("开始下载文件")
	default:
		m.Remark = "UnknowType"
	}
}

type Msg struct {
	Action  string `json:action`
	Address string `json:address`
	JobID   int64  `json:jobid`
	Remark  string `json:remark`
}

type statusM map[string]int64

var statusMap statusM = make(statusM)
var empty []byte

func (statusM) Flush(ip string) {
	statusMap[ip] = getNow()
}

func (statusM) Del(ip string) {
	delete(statusMap, ip)
}

func (statusM) Add(ip string) bool {
	_, ok := statusMap[ip]
	if ok {
		return false
	}
	statusMap.Flush(ip)
	return true
}

var GlobalLock sync.Mutex
var id int64 = getNow()

func NewID() int64 {
	GlobalLock.Lock()
	defer GlobalLock.Unlock()
	id = id + 1
	return id
}

func getNow() int64 {
	return time.Now().Unix()
}

func decode(b []byte) (*Msg, error) {
	j := getJsonPool()
	err := json.Unmarshal(b, j)
	if err != nil {
		return nil, err
	}
	return j, nil
}

func encode(msg *Msg) ([]byte, error) {
	return json.Marshal(*msg)
}

var JsonPool sync.Pool

func getJsonPool() *Msg {
	buf := JsonPool.Get()
	if buf != nil {
		b := buf.(*Msg)
		return b
	}
	return new(Msg)
}

func putJsonPool(m *Msg) {
	*m = Msg{}
	JsonPool.Put(m)
}

type rwc struct {
	Conn net.Conn
	Buf  *bufio.Reader
}

func (self *rwc) ReadLine() ([]byte, bool, error) {
	return self.Buf.ReadLine()
}
func (self *rwc) Write(b []byte) (int, error) {
	b = append(b, []byte("\r\n")...)
	return self.Conn.Write(b)
}

var rwcPool sync.Pool

func getrwcPool(con net.Conn) *rwc {
	buf := rwcPool.Get()
	if buf != nil {
		b := buf.(*rwc)
		b.Buf.Reset(con)
		b.Conn = con
		return b
	}
	rw := new(rwc)
	rw.Conn = con
	rw.Buf = bufio.NewReader(con)
	return rw
}

func putrwcPool(b *rwc) {
	b.Buf.Reset(nil)
	b.Conn = nil
	rwcPool.Put(b)
}
