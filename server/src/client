package main

import (
	"encoding/json"
	"fmt"
	"net"
	"os"
	"sync"
	"time"
)

var lock *sync.Mutex = new(sync.Mutex)

func main() {
	con, err := net.Dial("tcp", cfg.IP)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer con.Close()
	buf := getrwcPool(con)
	defer putrwcPool(buf)
	fmt.Fprint(buf, "Auth")
	go TestPing(buf)
	go HanderClientMsg(buf)
	select {}
}

type config struct {
	IP      string
	Inteval int
}

var clientMsgChan chan Msg = make(chan Msg, 1)

func HanderClientMsg(buf *rwc) {
	for {
		handlerMsg(buf)
	}
}

func handerclientmsg(buf *rwc) {
	lock.Lock()
	defer lock.Unlock()
	b, _ := json.Marshal(<-clientMsgChan)
write:
	_, err := buf.Write(b)
	if err != nil {
		reconnection(buf)
		goto write
	}
	line, _, err := buf.ReadLine()
	if err != nil {
		reconnection(buf)
		return
	}
	switch string(line) {
	case "AlreadyExist":
		fmt.Println(string(line))
		os.Exit(1)
	case "UnknowType":
		fmt.Println("UnknowType")
	case "JobExecError":
		fmt.Println("JobExecError")
	default:
		m, err := decode(line)
		if err == nil {
			fmt.Println(*m)
			putJsonPool(m)
		}
	}
}

var flushtime int64 = 0
var cfg config = config{"172.18.80.247:1789", 10}

func TestPing(buf *rwc) {
	for {
		if getNow()-flushtime > int64(cfg.Inteval) {
			ping(buf)
			flushtime = getNow()
			time.Sleep(time.Duration(cfg.Inteval) * time.Second)
		}
	}
}

func ping(buf *rwc) {
	lock.Lock()
	defer lock.Unlock()
	s := Msg{Action: "Test.Ping"}
	b, _ := json.Marshal(s)
	buf.Write(b)
	_, _, err := buf.ReadLine()
	if err != nil {
		reconnection(buf)
	}
	fmt.Println("ping ok")
}
func reconnection(buf *rwc) {
	var err error
	for {
		buf.Conn, err = net.Dial("tcp", cfg.IP)
		if err != nil {
			fmt.Println("重连失败.")
			time.Sleep(1e9)
			continue
		}
		break
	}
	fmt.Fprint(buf, "Auth")
	buf.Buf.Reset(buf.Conn)
}
